# Анализ безопасности приложения системы управления задачами

## 1. Описание работы приложения

Приложение представляет собой веб-систему управления задачами (task management system), построенную на стеке Node.js/Express с использованием SQLite базы данных.

### Архитектура приложения

#### Серверная часть

- **Фреймворк**: Express.js
- **База данных**: SQLite через библиотеку `sql.js`
- **Структура данных**:
  - `users` - таблица пользователей (id, username, password_hash, role, created_at)
  - `sessions` - таблица активных сессий (id, user_id, expires_at, created_at)
  - `csrf_tokens` - таблица CSRF токенов (token, session_id, expires_at, created_at)
  - `tasks` - таблица задач (id, user_id, title, description, completed, created_at, updated_at)

#### Клиентская часть

- Одностраничное приложение (SPA) на чистом JavaScript
- HTML5 + CSS для интерфейса
- AJAX-запросы для взаимодействия с API

#### Основной функционал

1. **Аутентификация и регистрация пользователей**

   - Регистрация новых пользователей
   - Вход в систему
   - Выход из системы
   - Роли: обычный пользователь (`user`) и администратор (`admin`)

2. **Управление задачами**

   - Создание задач (название, описание, статус выполнения)
   - Просмотр своих задач
   - Редактирование задач
   - Удаление задач
   - Администраторы могут просматривать и управлять всеми задачами
   - Административный поиск задач по имени пользователя и названию

3. **Защищённая передача данных**
   - Использование протокола Диффи-Хеллмана для шифрования учётных данных при аутентификации
   - AES-256-GCM для шифрования данных

### Поток работы приложения

1. **Инициализация**:

   - Сервер инициализирует базу данных при запуске
   - Создаёт необходимые таблицы, если их нет
   - Запускает периодическую очистку устаревших сессий и токенов

2. **Процесс аутентификации**:

   ```
   Клиент → GET /api/auth/key-exchange → Получение публичного ключа сервера
   Клиент → Генерация приватного ключа
   Клиент → Вычисление публичного ключа клиента
   Клиент → Вычисление общего секрета (shared secret)
   Клиент → Шифрование учётных данных (AES-256-GCM)
   Клиент → POST /api/auth/login (зашифрованные данные) → Сервер расшифровывает → Проверка пароля → Создание сессии
   Сервер → Установка cookie с сессией → Возврат CSRF токена
   ```

3. **Работа с задачами**:
   - Все запросы требуют аутентификации через middleware `requireAuth`
   - Проверка CSRF токена для всех изменяющих операций (POST, PUT, DELETE)
   - Автоматическая проверка прав доступа (пользователь видит только свои задачи, администратор - все)

---

## 2. Системы безопасности и их реализация

### 2.1. Аутентификация и управление сессиями

#### Механизм сессий

- **Хранение сессий**: в базе данных SQLite
- **Идентификатор сессии**: 32-байтовый случайный hex-строка (64 символа)
- **Время жизни**: 30 минут с автоматическим обновлением при каждом запросе
- **Подпись cookie**: HMAC-SHA256 для защиты от подделки

**Реализация** (`security/session.js`):

```javascript
// Создание сессии с уникальным ID
function createSession(userId) {
  const sessionId = crypto.randomBytes(32).toString("hex");
  const expiresAt = new Date(Date.now() + SESSION_DURATION).toISOString();
  // Сохранение в БД
}

// Подпись cookie через HMAC
function createSignedCookie(value) {
  const hmac = crypto.createHmac("sha256", HMAC_SECRET);
  hmac.update(value);
  const signature = hmac.digest("hex");
  return `${value}.${signature}`;
}

// Проверка подписи с защитой от timing attacks
function verifySignedCookie(signedValue) {
  // Использование crypto.timingSafeEqual для сравнения
}
```

#### Хеширование паролей

- **Алгоритм**: bcrypt с 10 раундами
- **Защита**: соль генерируется автоматически, хранится вместе с хешем

**Реализация** (`routes/auth.js`):

```javascript
const saltRounds = 10;
const passwordHash = await bcrypt.hash(password, saltRounds);
```

#### Защита от timing-атак

- При проверке пароля используется `bcrypt.compare()` (константное время)
- При неверном имени пользователя выполняется фиктивное хеширование для выравнивания времени ответа
- Использование `crypto.timingSafeEqual()` для сравнения HMAC подписей

### 2.2. Защита от CSRF (Cross-Site Request Forgery)

#### Механизм защиты

- **Хранение токенов**: в базе данных, привязаны к сессии
- **Время жизни**: 1 час
- **Одноразовость**: токен удаляется после использования
- **Проверка**: обязательна для всех изменяющих запросов (POST, PUT, DELETE)

**Реализация** (`security/csrf.js`):

```javascript
// Генерация токена
function createToken(sessionId) {
  const token = crypto.randomBytes(32).toString("hex");
  // Сохранение в БД с привязкой к сессии
}

// Middleware проверки
function csrfProtection(req, res, next) {
  if (req.method === "GET" || req.method === "HEAD") {
    return next(); // GET запросы не требуют токен
  }

  const token = req.headers["x-csrf-token"] || req.body?.csrf_token;
  if (!verifyToken(token, req.user.sessionId)) {
    return res.status(403).json({ error: "Недействительный CSRF токен" });
  }

  deleteToken(token); // Удаление после использования
}
```

**Использование на клиенте** (`public/app.js`):

- Токен получается через `GET /api/auth/csrf-token`
- Передаётся в заголовке `X-CSRF-Token` при каждом изменяющем запросе
- После использования токен обновляется

### 2.3. Протокол Диффи-Хеллмана для защиты учётных данных

#### Цель

Защита передачи паролей при аутентификации даже при использовании незащищённого HTTP соединения.

#### Реализация

- **Параметры**: RFC 3526 Group 14 (2048-битное простое число)
- **Алгоритм обмена ключами**:
  1. Сервер генерирует пару ключей (приватный/публичный)
  2. Клиент получает публичный ключ сервера
  3. Клиент генерирует свою пару ключей
  4. Обе стороны вычисляют общий секрет (shared secret)
  5. Общий секрет преобразуется в ключ шифрования через SHA-256
  6. Учётные данные шифруются AES-256-GCM перед отправкой

**Реализация** (`security/diffie-hellman.js`, `public/app.js`):

```javascript
// Серверная часть
function initKeyExchange() {
  const serverPrivateKey = generatePrivateKey();
  const serverPublicKey = computePublicKey(serverPrivateKey);
  // Сохранение приватного ключа с временным идентификатором
}

// Клиентская часть
async function secureAuthRequest(endpoint, credentials) {
  // 1. Получение параметров от сервера
  // 2. Генерация клиентского приватного ключа
  // 3. Вычисление общего секрета
  // 4. Шифрование данных AES-256-GCM
  // 5. Отправка зашифрованных данных
}
```

**Особенности**:

- Временные ключи хранятся в памяти сервера с TTL 5 минут
- Использование AES-256-GCM обеспечивает аутентифицированное шифрование
- IV (initialization vector) генерируется случайно для каждого запроса

### 2.4. Валидация и санитизация входных данных

#### Валидация username

- Длина: 3-20 символов
- Разрешённые символы: `[a-zA-Z0-9_]`
- Автоматическая обрезка пробелов

#### Валидация password

- Минимум: 6 символов
- Максимум: 100 символов

#### Валидация задач

- Название: обязательно, до 200 символов
- Описание: опционально, до 1000 символов
- Санитизация HTML: удаление угловых скобок `< >`

**Реализация** (`security/validation.js`):

```javascript
function validateTask(title, description) {
  const sanitizedTitle = sanitizeHTML(title.trim());
  // Проверка длины и содержания
}

function sanitizeHTML(str) {
  return str.replace(/[<>]/g, "").trim();
}
```

#### Защита от SQL Injection

- Использование параметризованных запросов (prepared statements)
- Все пользовательские данные передаются как параметры, а не через конкатенацию строк

**Пример**:

```javascript
// Безопасно
db.prepare("SELECT * FROM users WHERE username = ?").get(username);

// НЕ используется
db.run(`SELECT * FROM users WHERE username = '${username}'`); // ❌
```

### 2.5. Защита от XSS (Cross-Site Scripting)

#### Серверная часть

- Санитизация HTML в задачах (удаление `< >`)
- Валидация всех входных данных

#### Клиентская часть

- Экранирование HTML при отображении данных

**Реализация** (`public/app.js`):

```javascript
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text; // Автоматическое экранирование
  return div.innerHTML;
}
```

#### HTTP заголовки безопасности

Устанавливаются в `server.js`:

```javascript
res.setHeader("X-Content-Type-Options", "nosniff");
res.setHeader("X-Frame-Options", "DENY");
res.setHeader("X-XSS-Protection", "1; mode=block");
res.removeHeader("X-Powered-By"); // Скрытие информации о сервере
```

### 2.6. Контроль доступа (Authorization)

#### Ролевая модель

- **Пользователь** (`user`): может управлять только своими задачами
- **Администратор** (`admin`): может просматривать и управлять всеми задачами

**Реализация** (`routes/tasks.js`):

```javascript
// Проверка прав при доступе к задаче
if (req.user.role !== "admin" && task.user_id !== req.user.id) {
  return res.status(403).json({ error: "Недостаточно прав" });
}
```

#### Middleware проверки роли

```javascript
function requireRole(...allowedRoles) {
  return (req, res, next) => {
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: "Недостаточно прав доступа" });
    }
    next();
  };
}
```

### 2.7. Rate Limiting (ограничение частоты запросов)

#### Базовая реализация

- **Окно**: 15 минут
- **Лимит**: 100 запросов с одного IP
- **Хранение**: в памяти (Map)

**Реализация** (`server.js`):

```javascript
const rateLimitMap = new Map();
const RATE_LIMIT_WINDOW = 15 * 60 * 1000;
const RATE_LIMIT_MAX_REQUESTS = 100;

app.use((req, res, next) => {
  const ip = req.ip || req.connection.remoteAddress;
  // Проверка и обновление счётчика запросов
  if (limit.count >= RATE_LIMIT_MAX_REQUESTS) {
    return res.status(429).json({ error: "Слишком много запросов" });
  }
});
```

**Особенности**:

- Автоматическая очистка устаревших записей
- Базовая защита от брутфорс-атак

### 2.8. Очистка устаревших данных

#### Периодическая очистка

- Запускается при старте сервера
- Повторяется каждые 5 минут
- Удаляет:
  - Истёкшие сессии
  - Истёкшие CSRF токены

**Реализация** (`database.js`):

```javascript
function cleanupExpiredSessions() {
  const now = new Date().toISOString();
  db.prepare("DELETE FROM csrf_tokens WHERE expires_at < ?").run(now);
  db.prepare("DELETE FROM sessions WHERE expires_at < ?").run(now);
}
```

---

## 3. Данные в cookies и потенциальные угрозы безопасности

### 3.1. Данные, хранящиеся в cookies

#### Cookie `session`

- **Значение**: подписанный идентификатор сессии
- **Формат**: `{sessionId}.{HMAC_signature}`
  - `sessionId`: 64-символьная hex-строка (256 бит случайных данных)
  - `HMAC_signature`: 64-символьная hex-строка (HMAC-SHA256 подпись)

**Параметры cookie**:

```javascript
{
  httpOnly: true,        // ✅ Недоступен через JavaScript
  secure: false,         // ⚠️ Должно быть true в production (HTTPS)
  sameSite: 'strict',    // ✅ Защита от CSRF
  maxAge: 30 * 60 * 1000 // 30 минут
}
```

#### Что НЕ хранится в cookies

- ✅ Пароли (никогда не хранятся)
- ✅ Имена пользователей (хранятся только в сессии на сервере)
- ✅ CSRF токены (передаются через заголовки HTTP, хранятся в БД)
- ✅ Роли пользователей (извлекаются из БД при проверке сессии)

#### Что хранится в БД, но связано с cookie

- **sessions**: `sessionId` → `user_id`, `expires_at`
- **csrf_tokens**: `token` → `session_id`, `expires_at`

### 3.2. Потенциальные угрозы безопасности

#### Критические уязвимости

1. **⚠️ Отсутствие флага `secure` в production**

   - **Текущее состояние**: `secure: false`
   - **Проблема**: Cookie передаётся по незащищённому HTTP соединению
   - **Риск**: Перехват cookie через man-in-the-middle атаку
   - **Решение**: Установить `secure: true` при использовании HTTPS

2. **⚠️ Хранение сессий в памяти сервера (Диффи-Хеллман)**
   - **Проблема**: Ключи обмена хранятся в `Map` в памяти
   - **Риск**: Потеря при перезапуске сервера, но это не критично (временные ключи)
   - **Решение**: Использовать Redis или другую персистентную систему для продакшена

#### Средние уязвимости

3. **⚠️ Rate limiting по IP**

   - **Проблема**: Использование только IP-адреса для идентификации
   - **Риск**:
     - NAT: несколько пользователей за одним IP
     - Прокси/VPN: один пользователь может менять IP
     - Distributed атаки с разных IP
   - **Решение**:
     - Добавить проверку по username для логина
     - Использовать более продвинутые алгоритмы (token bucket, sliding window)
     - Интегрировать с сервисами типа Cloudflare

4. **⚠️ Простой HMAC секрет**

   - **Текущее состояние**: Генерируется случайно при запуске или берётся из `HMAC_SECRET`
   - **Проблема**: При каждом перезапуске генерируется новый секрет
   - **Риск**: Все существующие cookie становятся недействительными
   - **Решение**: Использовать постоянный секрет из переменных окружения

5. **⚠️ SQL Injection через невалидированные ID**

   - **Текущее состояние**: Используется `validateId()` для проверки
   - **Защита**: Параметризованные запросы
   - **Статус**: ✅ Хорошо защищено, но стоит дополнительно валидировать все ID

6. **⚠️ XSS через пользовательский контент**
   - **Защита**: Экранирование HTML на клиенте, санитизация на сервере
   - **Риск**: Если `escapeHtml()` не используется в каком-то месте
   - **Решение**: Использовать Content Security Policy (CSP) заголовки

#### Низкие уязвимости

7. **⚠️ Отсутствие Content Security Policy**

   - **Проблема**: Нет заголовка `Content-Security-Policy`
   - **Риск**: Возможность выполнения inline скриптов
   - **Решение**: Добавить CSP заголовок

8. **⚠️ Отсутствие защиты от clickjacking**

   - **Текущее состояние**: `X-Frame-Options: DENY` установлен ✅
   - **Статус**: Защищено, но можно дополнить CSP `frame-ancestors`

9. **⚠️ Информация об ошибках**

   - **Текущее состояние**: Общие сообщения об ошибках
   - **Риск**: Раскрытие информации через timing attacks (частично защищено)
   - **Решение**: Логирование ошибок без раскрытия деталей пользователю

10. **⚠️ Сессионное фиксирование (Session Fixation)**
    - **Защита**: Новый sessionId генерируется при каждой аутентификации ✅
    - **Статус**: Защищено

### 3.3. Рекомендации по улучшению безопасности

#### Критичные

1. ✅ Установить `secure: true` для cookies в production
2. ✅ Использовать постоянный `HMAC_SECRET` из переменных окружения
3. ✅ Включить HTTPS в production

#### Важные

4. ✅ Добавить Content Security Policy заголовки
5. ✅ Улучшить rate limiting (более сложные алгоритмы, проверка по username)
6. ✅ Добавить логирование подозрительной активности
7. ✅ Использовать Redis или другую систему для хранения сессий в production
8. ✅ Добавить двухфакторную аутентификацию (2FA) для администраторов

#### Дополнительные

9. ✅ Регулярное обновление зависимостей
10. ✅ Периодический аудит безопасности
11. ✅ Использование WAF (Web Application Firewall)
12. ✅ Регулярное резервное копирование БД с шифрованием

---

## Заключение

Приложение реализует комплексную систему безопасности с использованием современных практик:

✅ **Сильные стороны**:

- Шифрование учётных данных через Диффи-Хеллман
- Защита от CSRF через одноразовые токены
- Подписанные сессии с защитой от подделки
- Защита от SQL Injection через параметризованные запросы
- Защита от XSS через санитизацию и экранирование
- Контроль доступа на основе ролей
- Базовый rate limiting

⚠️ **Области для улучшения**:

- Настройка `secure: true` для cookies в production
- Использование постоянного HMAC секрета
- Улучшение rate limiting
- Добавление CSP заголовков
- Использование Redis для сессий в production

В целом, приложение демонстрирует хороший уровень безопасности для учебного проекта, но требует дополнительных улучшений для production использования.
