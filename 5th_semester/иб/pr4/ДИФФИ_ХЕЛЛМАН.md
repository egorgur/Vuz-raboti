# Протокол Диффи-Хеллмана в приложении

## Теоретическая основа

Протокол Диффи-Хеллмана позволяет двум сторонам выработать **общий секретный ключ** через открытый канал связи, не передавая сам ключ.

### Математическая основа

1. Выбираются публичные параметры:
   - `p` — большое простое число
   - `g` — генератор (примитивный корень по модулю p)

2. Каждая сторона генерирует **секретный ключ**:
   - Сервер: `a` (случайное число)
   - Клиент: `b` (случайное число)

3. Вычисляются **публичные ключи**:
   - Сервер: `A = g^a mod p`
   - Клиент: `B = g^b mod p`

4. Стороны обмениваются публичными ключами через открытый канал

5. Каждая сторона вычисляет **общий секрет**:
   - Сервер: `K = B^a mod p`
   - Клиент: `K = A^b mod p`

Оба получают одинаковый `K`, так как:
```
K = B^a mod p = (g^b)^a mod p = g^(ab) mod p = (g^a)^b mod p = A^b mod p
```

### Почему это безопасно?

Злоумышленник видит: `p`, `g`, `A`, `B`

Чтобы вычислить `K`, нужно знать `a` или `b`. Для этого нужно решить **задачу дискретного логарифмирования**:
```
A = g^a mod p → найти a
```

При достаточно большом `p` (2048 бит) это вычислительно невозможно.

---

## Реализация в приложении

### Шаг 1: Инициализация обмена (сервер)

Клиент запрашивает параметры:

```javascript
// Клиент (public/app.js)
const keyExchangeResponse = await fetch('/api/auth/key-exchange');
const keyData = await keyExchangeResponse.json();
// keyData = { exchangeId, serverPublicKey, p, g }
```

Сервер генерирует свой ключ и возвращает параметры:

```javascript
// Сервер (security/diffie-hellman.js)
function initKeyExchange() {
  const exchangeId = crypto.randomBytes(16).toString('hex');
  const serverPrivateKey = generatePrivateKey();  // случайное 256-бит число
  const serverPublicKey = computePublicKey(serverPrivateKey);  // A = g^a mod p
  
  // Сохраняем приватный ключ для завершения обмена
  dhKeyStore.set(exchangeId, {
    privateKey: serverPrivateKey,
    createdAt: Date.now()
  });
  
  return {
    exchangeId,
    serverPublicKey: serverPublicKey.toString(16),
    p: DH_PARAMS.p.toString(16),
    g: DH_PARAMS.g.toString()
  };
}
```

### Шаг 2: Генерация ключей клиента

```javascript
// Клиент (public/app.js)
const p = BigInt('0x' + keyData.p);
const g = BigInt(keyData.g);
const serverPublicKey = BigInt('0x' + keyData.serverPublicKey);

// Генерируем приватный ключ клиента
const clientPrivateKey = generatePrivateKey();

// Вычисляем публичный ключ клиента: B = g^b mod p
const clientPublicKey = computePublicKey(clientPrivateKey, g, p);
```

### Шаг 3: Вычисление общего секрета (клиент)

```javascript
// Клиент (public/app.js)
// K = A^b mod p (A - публичный ключ сервера, b - приватный ключ клиента)
const sharedSecret = computeSharedSecret(serverPublicKey, clientPrivateKey, p);
```

Функция модульного возведения в степень:

```javascript
function modPow(base, exponent, modulus) {
  if (modulus === BigInt(1)) return BigInt(0);
  
  let result = BigInt(1);
  base = base % modulus;
  
  while (exponent > BigInt(0)) {
    if (exponent % BigInt(2) === BigInt(1)) {
      result = (result * base) % modulus;
    }
    exponent = exponent / BigInt(2);
    base = (base * base) % modulus;
  }
  
  return result;
}
```

### Шаг 4: Получение ключа шифрования

Общий секрет преобразуется в 256-битный ключ через SHA-256:

```javascript
// Клиент (public/app.js)
async function deriveEncryptionKey(sharedSecret) {
  const secretHex = sharedSecret.toString(16).padStart(512, '0');
  const secretBytes = new Uint8Array(secretHex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
  const hashBuffer = await crypto.subtle.digest('SHA-256', secretBytes);
  return new Uint8Array(hashBuffer);
}
```

```javascript
// Сервер (security/diffie-hellman.js)
function deriveEncryptionKey(sharedSecret) {
  const secretHex = sharedSecret.toString(16).padStart(512, '0');
  const secretBuffer = Buffer.from(secretHex, 'hex');
  return crypto.createHash('sha256').update(secretBuffer).digest();
}
```

### Шаг 5: Шифрование данных (клиент)

Используется AES-256-GCM:

```javascript
// Клиент (public/app.js)
async function encryptData(data, keyBytes) {
  const key = await crypto.subtle.importKey(
    'raw', keyBytes, { name: 'AES-GCM' }, false, ['encrypt']
  );
  
  const iv = crypto.getRandomValues(new Uint8Array(12));  // 96-бит IV
  const encodedData = new TextEncoder().encode(data);
  
  const encryptedBuffer = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: iv },
    key,
    encodedData
  );
  
  // Последние 16 байт - authTag (для проверки целостности)
  const encryptedArray = new Uint8Array(encryptedBuffer);
  const encrypted = encryptedArray.slice(0, -16);
  const authTag = encryptedArray.slice(-16);
  
  return {
    encrypted: toHex(encrypted),
    iv: toHex(iv),
    authTag: toHex(authTag)
  };
}
```

### Шаг 6: Отправка зашифрованных данных

```javascript
// Клиент (public/app.js)
const encryptedData = await encryptData(JSON.stringify(credentials), encryptionKey);

const response = await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    exchangeId: keyData.exchangeId,
    clientPublicKey: clientPublicKey.toString(16),
    encryptedData: encryptedData
  })
});
```

### Шаг 7: Расшифровка на сервере

```javascript
// Сервер (routes/auth.js)
if (req.body.exchangeId && req.body.clientPublicKey && req.body.encryptedData) {
  // Вычисляем общий секрет: K = B^a mod p
  const encryptionKey = completeKeyExchange(req.body.exchangeId, req.body.clientPublicKey);
  
  // Расшифровываем данные
  const decryptedJson = decryptData(
    req.body.encryptedData.encrypted,
    req.body.encryptedData.iv,
    req.body.encryptedData.authTag,
    encryptionKey
  );
  
  const { username, password } = JSON.parse(decryptedJson);
}
```

```javascript
// Сервер (security/diffie-hellman.js)
function completeKeyExchange(exchangeId, clientPublicKeyHex) {
  const keyData = dhKeyStore.get(exchangeId);
  const clientPublicKey = BigInt('0x' + clientPublicKeyHex);
  
  // K = B^a mod p
  const sharedSecret = computeSharedSecret(clientPublicKey, keyData.privateKey);
  const encryptionKey = deriveEncryptionKey(sharedSecret);
  
  dhKeyStore.delete(exchangeId);  // Одноразовое использование
  return encryptionKey;
}

function decryptData(encryptedDataHex, ivHex, authTagHex, key) {
  const iv = Buffer.from(ivHex, 'hex');
  const authTag = Buffer.from(authTagHex, 'hex');
  const encryptedData = Buffer.from(encryptedDataHex, 'hex');
  
  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encryptedData, null, 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}
```

---

## Схема обмена

```
┌─────────┐                                    ┌─────────┐
│ Клиент  │                                    │ Сервер  │
└────┬────┘                                    └────┬────┘
     │                                              │
     │  1. GET /api/auth/key-exchange               │
     │─────────────────────────────────────────────>│
     │                                              │
     │                          Генерирует a        │
     │                          A = g^a mod p       │
     │                                              │
     │  2. { exchangeId, serverPublicKey: A, p, g } │
     │<─────────────────────────────────────────────│
     │                                              │
     │  Генерирует b                                │
     │  B = g^b mod p                               │
     │  K = A^b mod p                               │
     │  Шифрует {username, password} ключом K       │
     │                                              │
     │  3. POST /api/auth/login                     │
     │  { exchangeId, clientPublicKey: B,           │
     │    encryptedData: {...} }                    │
     │─────────────────────────────────────────────>│
     │                                              │
     │                          K = B^a mod p       │
     │                          Расшифровывает      │
     │                          Проверяет логин     │
     │                                              │
     │  4. { user, csrf_token }                     │
     │<─────────────────────────────────────────────│
     │                                              │
```

---

## Что видит злоумышленник

При перехвате трафика злоумышленник видит:

1. **Параметры DH**: `p`, `g`, `A` (публичный ключ сервера)
2. **Публичный ключ клиента**: `B`
3. **Зашифрованные данные**: `encryptedData`, `iv`, `authTag`

**Не может вычислить**:
- Приватные ключи `a` и `b`
- Общий секрет `K`
- Расшифрованный пароль

---

## Используемые параметры

| Параметр | Значение |
|----------|----------|
| Простое число p | 2048 бит (RFC 3526 Group 14) |
| Генератор g | 2 |
| Приватные ключи | 256 бит (случайные) |
| Алгоритм шифрования | AES-256-GCM |
| Хеш для ключа | SHA-256 |
| Время жизни exchangeId | 5 минут |

